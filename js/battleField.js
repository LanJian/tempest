// Generated by CoffeeScript 1.4.0
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  window.BattleField = (function(_super) {

    __extends(BattleField, _super);

    function BattleField(opts, state, player, enemy) {
      this.state = state;
      this.player = player;
      this.enemy = enemy;
      BattleField.__super__.constructor.call(this, opts);
      Common.battleField = this;
      this.selectedUnit = null;
      this.curTile = null;
      this.highlightLayer = [];
      this.loadout;
      this.target;
    }

    BattleField.prototype.init = function() {
      this.tileBoundingPoly.color = 'rgba(50,20,240,0.4)';
      this.attRangePoly = {};
      $.extend(this.attRangePoly, this.tileBoundingPoly);
      this.attRangePoly.color = 'rgba(240,20,50,0.4)';
      this.moveRangePoly = {};
      $.extend(this.moveRangePoly, this.tileBoundingPoly);
      this.state.changeToMode('select');
      BattleField.__super__.init.call(this);
      this.addUnits(this.player);
      this.addUnits(this.enemy);
      this.addListener('mouseMove', this.onMouseMove.bind(this));
      this.addListener('keyPress', this.onKeyPress.bind(this));
      window.addEventListener("keydown", (function(e) {
        var _ref;
        if ((_ref = e.keyCode) === 37 || _ref === 38 || _ref === 39 || _ref === 40 || _ref === 27 || _ref === 87 || _ref === 65 || _ref === 83 || _ref === 68) {
          return e.preventDefault();
        }
      }), false);
      this.onKeyDown(65, (function() {
        console.log('Pos', this.position);
        return this.changePos(this.position, {
          x: 15,
          y: 0
        });
      }).bind(this));
      this.onKeyDown(68, (function() {
        return this.changePos(this.position, {
          x: -15,
          y: 0
        });
      }).bind(this));
      this.onKeyDown(87, (function() {
        return this.changePos(this.position, {
          x: 0,
          y: 15
        });
      }).bind(this));
      this.onKeyDown(83, (function() {
        return this.changePos(this.position, {
          x: 0,
          y: -15
        });
      }).bind(this));
      this.onKeyDown(37, (function() {
        return this.changePos(this.position, {
          x: 15,
          y: 0
        });
      }).bind(this));
      this.onKeyDown(38, (function() {
        return this.changePos(this.position, {
          x: 0,
          y: 15
        });
      }).bind(this));
      this.onKeyDown(39, (function() {
        return this.changePos(this.position, {
          x: -15,
          y: 0
        });
      }).bind(this));
      this.onKeyDown(40, (function() {
        return this.changePos(this.position, {
          x: 0,
          y: -15
        });
      }).bind(this));
      this.onKeyDown(27, (function() {
        this.resetHighlight();
        this.state.changeToMode('select');
        return this.state.type = 'normal';
      }).bind(this));
      this.addListener('unitSelected', this.onUnitSelected.bind(this));
      this.addListener('unitMove', this.onUnitMove.bind(this));
      this.addListener('loadoutSelectTarget', this.onLoadoutSelectTarget.bind(this));
      this.addListener('applyLoadout', this.onApplyLoadout.bind(this));
      this.addListener('selectAttackTarget', this.onSelectAttackTarget.bind(this));
      return this.addListener('unitAttack', this.onUnitAttack.bind(this));
    };

    BattleField.prototype.onKeyPress = function(evt) {
      if (evt.which === 13) {
        if (Common.state.turn !== this.enemy) {
          this.resetHighlight();
          return this.state.endTurn();
        }
      }
    };

    BattleField.prototype.onMouseMove = function(evt) {
      var i, j, row, tile, x, y, _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = this.tiles.length - 1; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        row = this.tiles[i];
        _results.push((function() {
          var _j, _ref1, _results1;
          _results1 = [];
          for (j = _j = 0, _ref1 = row.length - 1; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
            tile = row[j];
            x = i * -this.tileXOffset + j * this.tileXOffset + this.mapOffset;
            y = i * this.tileYOffset + j * this.tileYOffset;
            if (tile.containsPoint(evt.x - x + 1, evt.y - y + 1)) {
              _results1.push(tile.showPoly());
            } else {
              _results1.push(tile.hidePoly());
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    BattleField.prototype.onUnitSelected = function(evt) {
      this.selectedUnit = evt.target;
      if (this.selectedUnit.belongsTo !== this.player) {
        Common.game.battleLog('Cannot control this unit');
        return;
      }
      if (this.state.turn === this.enemy) {
        Common.game.battleLog("Cannot control unit during enemy's turn");
        return;
      }
      if (this.selectedUnit.moveTokens <= 0) {
        Common.game.battleLog('Cannot move anymore in this turn');
        return;
      }
      this.curTile = evt.origin;
      this.state.changeToMode('move');
      return this.highlightMoveRange(this.selectedUnit, this.selectedUnit.stats.moveRange, this.moveRangePoly);
    };

    BattleField.prototype.onUnitMove = function(evt) {
      this.resetHighlight();
      return this.moveUnit(this.selectedUnit, evt.row, evt.col);
    };

    BattleField.prototype.onLoadoutSelectTarget = function(evt) {
      this.state.changeToMode('select');
      this.state.type = 'loadout';
      return this.loadout = evt.item;
    };

    BattleField.prototype.onApplyLoadout = function(evt) {
      var col, row, unitToAdd;
      if (this.loadout.stats.cost <= this.getPlayerIP(this.player)) {
        Common.game.battleLog('Please select loadout item target');
        if (evt.target instanceof Unit && (this.loadout instanceof Armor || this.loadout instanceof Weapon)) {
          if (evt.target.belongsTo === this.enemy) {
            Common.game.battleLog('Cannot equip item to enemy unit');
          } else {
            evt.target.equip(this.loadout);
            Common.loadout.remove(this.loadout);
            this.setPlayerIP(this.player, this.getPlayerIP(this.player) - this.loadout.stats.cost);
          }
        } else if (evt.target instanceof BFTile && this.loadout instanceof Unit) {
          col = evt.target.col;
          row = evt.target.row;
          if (this.loadout instanceof Soldier) {
            unitToAdd = new Soldier(row, col);
          } else if (this.loadout instanceof Archer) {
            unitToAdd = new Archer(row, col);
          } else if (this.loadout instanceof Knight) {
            unitToAdd = new Knight(row, col);
          } else {
            unitToAdd = new Soldier(row, col);
          }
          Common.player.addUnit(unitToAdd);
          this.addObject(unitToAdd, row, col);
          this.tiles[row][col].occupiedBy = unitToAdd;
          unitToAdd.onTile = evt.target;
          Common.loadout.remove(this.loadout);
          this.setPlayerIP(this.player, this.getPlayerIP(this.player) - this.loadout.stats.cost);
        } else {
          Common.game.battleLog('Invalid target to apply loadout item');
        }
      } else {
        Common.game.battleLog('Not enough Initiative Points');
      }
      Common.cPanel.updatePanel();
      this.state.changeToMode('select');
      return this.state.type = 'normal';
    };

    BattleField.prototype.onSelectAttackTarget = function(evt) {
      Common.game.changeCursor('cursor/attack.cur');
      this.resetHighlight();
      if (this.selectedUnit.belongsTo !== this.state.turn) {
        Common.game.battleLog('Cannot control this unit');
        return;
      }
      if (this.selectedUnit.actionTokens <= 0) {
        Common.game.battleLog('Cannot perform more attacks this turn');
        this.state.changeToMode('select');
        return;
      }
      if (!this.selectedUnit.weaponActive) {
        Common.game.battleLog('Unit does not have weapon to attack');
        this.state.changeToMode('select');
        return;
      }
      this.state.changeToMode('attack');
      if (this.selectedUnit.weaponActive) {
        return this.highlightAttackRange(this.selectedUnit, this.selectedUnit.getWeaponRange(), this.attRangePoly);
      } else {
        alert("Unit does not have weapon to attack");
        return this.state.changeToMode('select');
      }
    };

    BattleField.prototype.onUnitAttack = function(evt) {
      if (evt.target.belongsTo === this.state.turn) {
        Common.game.battleLog('Cannot attack own unit');
        return;
      }
      this.resetHighlight();
      if (evt.target instanceof Unit) {
        if ((this.inAttackRange(this.selectedUnit.onTile, evt.target.onTile, this.selectedUnit.getWeaponRange())) && (this.selectedUnit.onTile !== evt.target.onTile)) {
          this.unitAttack(this.selectedUnit, evt.target);
        }
      } else {

      }
      return this.state.changeToMode('select');
    };

    BattleField.prototype.addUnits = function(player) {
      var u, _i, _len, _ref, _results;
      _ref = player.units;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        u = _ref[_i];
        this.addObject(u, u.row, u.col);
        _results.push(u.onTile = this.tiles[u.row][u.col]);
      }
      return _results;
    };

    BattleField.prototype.changePos = function(position, change) {
      if ((position.x > 300) && (change.x > 0)) {

      } else if ((position.x < -1785) && (change.x < 0)) {

      } else {
        position.x += change.x;
      }
      if ((position.y < -790) && (change.y < 0)) {

      } else if ((position.y > 350) && (change.y > 0)) {

      } else {
        return position.y += change.y;
      }
    };

    BattleField.prototype.moveUnit = function(u, row, col) {
      var fromTile, pathQ, targetTile;
      Common.actionComplete = false;
      fromTile = u.onTile;
      targetTile = this.tiles[row][col];
      if (!(this.inMoveRange(fromTile, targetTile, u.stats.moveRange)) || (targetTile.occupiedBy !== null)) {
        this.state.changeToMode('select');
        this.selectedUnit = null;
        Common.selected = null;
        Common.cPanel.updatePanel();
        Common.actionComplete = true;
        return;
      }
      if (!(targetTile.occupiedBy != null)) {
        fromTile.occupiedBy = null;
        pathQ = this.findPath(fromTile, targetTile);
        if (pathQ != null) {
          this.state.changeToMode('unitMoving');
          fromTile.occupiedBy = null;
          this.moveUnitPath(pathQ, u, targetTile);
          return u.moveTokens -= 1;
        } else {
          Common.game.battleLog('Cant move to that tile');
          return fromTile.occupiedBy = u;
        }
      }
    };

    BattleField.prototype.unitAttack = function(attacker, target) {
      attacker.attack(target);
      return attacker.actionTokens -= 1;
    };

    BattleField.prototype.findEmptyTile = function(tile, unit) {
      var c, q, r, row, t, _i, _j, _len, _len1, _ref;
      q = [];
      q.push(tile);
      this.resetMapArray();
      this.genMap(this.m, null, unit.onTile);
      _ref = this.tiles;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        row = _ref[_i];
        for (_j = 0, _len1 = row.length; _j < _len1; _j++) {
          t = row[_j];
          t.seen = false;
        }
      }
      while (q.length > 0) {
        t = q.shift();
        if (t.seen === true) {
          continue;
        }
        r = t.row;
        c = t.col;
        if ((t.occupiedBy === null) && (t.type !== 'water') && (this.m[t.row][t.col] <= unit.stats.moveRange)) {
          return t;
        }
        t.seen = true;
        if (r + 1 < Common.mapSize.row) {
          q.push(this.tiles[r + 1][c]);
        }
        if (c + 1 < Common.mapSize.col) {
          q.push(this.tiles[r][c + 1]);
        }
        if (r - 1 >= 0) {
          q.push(this.tiles[r - 1][c]);
        }
        if (c - 1 >= 0) {
          q.push(this.tiles[r][c - 1]);
        }
      }
      return null;
    };

    BattleField.prototype.findPath = function(startTile, endTile) {
      this.resetMapArray();
      this.genMap(this.m, startTile, this.tiles[endTile.row][endTile.col]);
      return this.genPath(this.m, this.tiles[startTile.row][startTile.col]);
    };

    BattleField.prototype.genMap = function(map, startTile, endTile) {
      var better, c, coun, current, e, ele, elem, index, newList, pathQ, r, re, _i, _j, _k, _len, _len1, _len2, _results;
      pathQ = [
        {
          row: endTile.row,
          col: endTile.col,
          counter: 0
        }
      ];
      index = 0;
      current = pathQ[0];
      while (current != null) {
        r = current.row;
        c = current.col;
        coun = current.counter + this.tiles[r][c].tileMoveCost;
        if (startTile != null) {
          if (r === startTile.row && c === startTile.col) {
            break;
          }
        }
        newList = [
          {
            row: r,
            col: c - 1,
            counter: coun
          }, {
            row: r + 1,
            col: c,
            counter: coun
          }, {
            row: r - 1,
            col: c,
            counter: coun
          }, {
            row: r,
            col: c + 1,
            counter: coun
          }
        ];
        for (_i = 0, _len = newList.length; _i < _len; _i++) {
          ele = newList[_i];
          better = false;
          for (_j = 0, _len1 = pathQ.length; _j < _len1; _j++) {
            e = pathQ[_j];
            if (e.col === ele.col && e.row === ele.row) {
              if (e.counter < ele.counter) {
                better = true;
              } else {
                re = e;
              }
            }
          }
          pathQ.remove(re);
          if (better === true) {

          } else if (ele.col < 0 || ele.col >= Common.mapSize.col) {

          } else if (ele.row < 0 || ele.row >= Common.mapSize.row) {

          } else if (this.tiles[ele.row][ele.col].occupiedBy != null) {

          } else {
            pathQ.push(ele);
          }
        }
        index += 1;
        current = pathQ[index];
      }
      _results = [];
      for (_k = 0, _len2 = pathQ.length; _k < _len2; _k++) {
        elem = pathQ[_k];
        _results.push(map[elem.row][elem.col] = elem.counter);
      }
      return _results;
    };

    BattleField.prototype.genPath = function(m, startTile) {
      var best, col, counter, current, possibleSteps, queue, row, s, steps, _i, _len;
      current = {
        row: startTile.row,
        col: startTile.col
      };
      queue = [current];
      steps = m[current.row][current.col];
      while (steps !== 0) {
        possibleSteps = [
          {
            row: current.row + 1,
            col: current.col
          }, {
            row: current.row - 1,
            col: current.col
          }, {
            row: current.row,
            col: current.col + 1
          }, {
            row: current.row,
            col: current.col - 1
          }
        ];
        best = 9999;
        row = 0;
        col = 0;
        if (m[current.row][current.col] === '-') {
          return;
        }
        for (_i = 0, _len = possibleSteps.length; _i < _len; _i++) {
          s = possibleSteps[_i];
          counter = m[s.row][s.col];
          if (counter < best) {
            row = s.row;
            col = s.col;
            best = counter;
          }
        }
        steps = best;
        queue.push({
          row: row,
          col: col
        });
        current = {
          row: row,
          col: col
        };
      }
      return queue;
    };

    BattleField.prototype.printPath = function(m) {
      var i, j, row, s, _i, _j, _k, _ref, _ref1, _ref2, _results;
      s = "";
      for (i = _i = 0, _ref = m.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (i < 10) {
          s = s + "   " + i;
        } else {
          s = s + "  " + i;
        }
      }
      console.log(s);
      _results = [];
      for (i = _j = 0, _ref1 = m.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        s = "";
        row = m[i];
        for (j = _k = 0, _ref2 = row.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; j = 0 <= _ref2 ? ++_k : --_k) {
          s = s + "   " + m[i][j];
        }
        s += i;
        _results.push(console.log(s));
      }
      return _results;
    };

    BattleField.prototype.moveUnitPath = function(pathQ, unit, finalTile) {
      var current, tween;
      if (pathQ.length === 0) {
        Common.actionComplete = true;
        this.state.changeToMode('select');
        unit.sprite.stop();
        finalTile.occupiedBy = unit;
        unit.onTile = finalTile;
        console.log('walk complete');
      } else {
        current = pathQ[0];
        unit.onTile.occupiedBy = null;
        tween = unit.moveTo(this.tiles[current.row][current.col]);
        unit.onTile = this.tiles[current.row][current.col];
        return tween.onComplete((function() {
          pathQ.remove(pathQ[0]);
          return this.moveUnitPath(pathQ, unit, finalTile);
        }).bind(this));
      }
    };

    BattleField.prototype.highlightMoveRange = function(unit, range, poly) {
      var e, i, j, p, row, s, tile, _i, _ref, _results;
      this.resetMapArray();
      s = (new Date()).getTime();
      this.genMap(this.m, null, unit.onTile);
      e = (new Date()).getTime();
      this.resetHighlight();
      _results = [];
      for (i = _i = 0, _ref = this.tiles.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        row = this.tiles[i];
        _results.push((function() {
          var _j, _ref1, _results1;
          _results1 = [];
          for (j = _j = 0, _ref1 = row.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
            tile = row[j];
            if ((this.m[i][j] <= range) && tile.walkable) {
              p = {};
              $.extend(true, p, poly);
              p.setPosition(tile.position.x, tile.position.y);
              _results1.push(this.highlightLayer.push(p));
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    BattleField.prototype.inMoveRange = function(curPos, tarPos, range) {
      this.resetMapArray();
      this.genMap(this.m, null, curPos);
      return (this.m[tarPos.row][tarPos.col] <= range) && tarPos.walkable;
    };

    BattleField.prototype.highlightAttackRange = function(unit, range, poly) {
      var i, j, p, row, tile, _i, _ref, _results;
      this.resetHighlight();
      _results = [];
      for (i = _i = 0, _ref = this.tiles.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        row = this.tiles[i];
        _results.push((function() {
          var _j, _ref1, _results1;
          _results1 = [];
          for (j = _j = 0, _ref1 = row.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
            tile = row[j];
            if (this.inAttackRange(unit.onTile, tile, range)) {
              p = {};
              $.extend(true, p, poly);
              this.highlightLayer.push(p);
              _results1.push(p.setPosition(tile.position.x, tile.position.y));
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    BattleField.prototype.inAttackRange = function(curPos, tarPos, range) {
      var diffCol, diffRow;
      diffCol = Math.abs(tarPos.col - curPos.col);
      diffRow = Math.abs(tarPos.row - curPos.row);
      return (diffCol + diffRow) <= range;
    };

    BattleField.prototype.resetMapArray = function() {
      var i, j, row, _i, _ref, _results;
      this.m = [];
      _results = [];
      for (i = _i = 0, _ref = this.tiles.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        row = this.tiles[i];
        this.m[i] = [];
        _results.push((function() {
          var _j, _ref1, _results1;
          _results1 = [];
          for (j = _j = 0, _ref1 = row.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
            _results1.push(this.m[i][j] = "-");
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    BattleField.prototype.removeUnit = function(unit) {
      unit.onTile.occupiedBy = null;
      this.objLayer.remove(unit);
      this.player.removeUnit(unit);
      return this.enemy.removeUnit(unit);
    };

    BattleField.prototype.resetHighlight = function() {
      return this.highlightLayer = [];
    };

    BattleField.prototype.getPlayerIP = function(player) {
      return player.initiativePoints;
    };

    BattleField.prototype.setPlayerIP = function(player, ip) {
      var evt;
      player.initiativePoints = ip;
      evt = {
        type: 'ipValueChange'
      };
      return this.dispatchEvent(evt);
    };

    BattleField.prototype.updateCP = function() {
      return Common.cPanel.updatePanel();
    };

    BattleField.prototype.addObjectHelper = function(obj, i, j, listener) {
      var x, y, _i, _j, _ref, _ref1, _results;
      if (listener == null) {
        listener = null;
      }
      if (listener) {
        this.removeListener(listener);
      }
      x = i * -this.tileXOffset + j * this.tileXOffset + this.mapOffset;
      y = i * this.tileYOffset + j * this.tileYOffset;
      y -= obj.size.h;
      y += this.tileHeight;
      for (i = _i = 0, _ref = obj.width - 1; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        y += this.tileYOffset * 2;
        x -= this.tileXOffset;
      }
      obj.setPosition(x, y);
      obj.anchorY = obj.size.h;
      _results = [];
      for (i = _j = 0, _ref1 = obj.width; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        _results.push(obj.anchorY -= this.tileYOffset);
      }
      return _results;
    };

    BattleField.prototype.handle = function(evt) {
      var child, i, isHandled, listener, _i, _j, _k, _len, _ref, _ref1, _ref2, _ref3, _ref4;
      if (Event.isMouseEvent(evt)) {
        if (!this.containsPoint(evt.x, evt.y)) {
          return false;
        }
        evt.target = this;
      }
      if ((_ref = evt.type) === 'click') {
        if (this.children.length >= 0) {
          for (i = _i = _ref1 = this.children.length - 1; _i >= 0; i = _i += -1) {
            child = this.children[i];
            evt.x = evt.x - child.position.x;
            evt.y = evt.y - child.position.y;
            isHandled = child.handle(evt);
            evt.x = evt.x + child.position.x;
            evt.y = evt.y + child.position.y;
            if (Event.isMouseEvent(evt && isHandled)) {
              return true;
            }
          }
        }
      }
      if ((_ref2 = evt.type) === 'click' || _ref2 === 'spriteImageLoaded' || _ref2 === 'resize' || _ref2 === 'spriteStopAnim') {
        if (this.objLayer.length >= 0) {
          for (i = _j = _ref3 = this.objLayer.length - 1; _j >= 0; i = _j += -1) {
            child = this.objLayer[i];
            evt.x = evt.x - child.position.x;
            evt.y = evt.y - child.position.y;
            isHandled = child.handle(evt);
            evt.x = evt.x + child.position.x;
            evt.y = evt.y + child.position.y;
            if (Event.isMouseEvent(evt && isHandled)) {
              return true;
            }
          }
        }
      }
      isHandled = false;
      _ref4 = this.listeners;
      for (_k = 0, _len = _ref4.length; _k < _len; _k++) {
        listener = _ref4[_k];
        if (evt.type === listener.type) {
          isHandled = true;
          listener.handler(evt);
        }
      }
      return isHandled;
    };

    BattleField.prototype.addObject = function(obj, i, j) {
      var ii, jj, listener, _i, _j, _ref, _ref1;
      this.objLayer.push(obj);
      for (ii = _i = 0, _ref = obj.width; 0 <= _ref ? _i < _ref : _i > _ref; ii = 0 <= _ref ? ++_i : --_i) {
        for (jj = _j = 0, _ref1 = obj.height; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; jj = 0 <= _ref1 ? ++_j : --_j) {
          this.tiles[i + ii][j + jj].occupiedBy = obj;
        }
      }
      if (obj.loaded) {
        addObjectHelper(obj, i, j);
        return;
      }
      return listener = this.addListener('bfObjectReady', (function(evt) {
        if (obj === evt.target) {
          return this.addObjectHelper(evt.target, i, j, listener);
        }
      }).bind(this));
    };

    BattleField.prototype.draw = function(ctx) {
      var child, obj, tile, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
      ctx.save();
      ctx.translate(this.position.x, this.position.y);
      _ref = this.children;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        if (child.visible) {
          child.draw(ctx);
        }
      }
      _ref1 = this.highlightLayer;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        tile = _ref1[_j];
        if (tile.visible) {
          tile.draw(ctx);
        }
      }
      this.objLayer.sort((function(a, b) {
        return (a.position.y + a.anchorY) - (b.position.y + b.anchorY);
      }));
      _ref2 = this.objLayer;
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        obj = _ref2[_k];
        if (obj.visible) {
          obj.draw(ctx);
        }
      }
      return ctx.restore();
    };

    return BattleField;

  })(IsometricMap);

}).call(this);
