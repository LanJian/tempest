// Generated by CoffeeScript 1.4.0
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  window.Unit = (function(_super) {

    __extends(Unit, _super);

    function Unit(charSpriteSheet, stats, onTile, belongsTo, iconFile, row, col, enemy) {
      this.charSpriteSheet = charSpriteSheet;
      this.stats = stats;
      this.onTile = onTile;
      this.belongsTo = belongsTo;
      this.iconFile = iconFile;
      this.row = row;
      this.col = col;
      this.enemy = enemy;
      this.curhp = this.stats.hp;
      this.weapons = [];
      if (this.weapons) {
        this.weaponActive = this.weapons[0];
      }
      this.lastDir = 'upright';
      if (this.enemy) {
        this.lastDir = 'downleft';
      }
      this.armors = [];
      this.moveTokens = 1;
      this.actionTokens = 1;
      this.cfg = [1, 7, 7, 5];
      this.sprite = new Sprite(this.charSpriteSheet);
      Unit.__super__.constructor.call(this, this.sprite, 1, 1);
    }

    Unit.prototype.init = function() {
      Unit.__super__.init.call(this);
      this.sprite.addAnimation({
        id: 'idle-downleft',
        row: 0,
        fps: this.cfg[0]
      });
      this.sprite.addAnimation({
        id: 'idle-upright',
        row: 1,
        fps: this.cfg[0]
      });
      this.sprite.addAnimation({
        id: 'idle-downright',
        row: 2,
        fps: this.cfg[0]
      });
      this.sprite.addAnimation({
        id: 'idle-upleft',
        row: 3,
        fps: this.cfg[0]
      });
      this.sprite.addAnimation({
        id: 'walk-downleft',
        row: 4,
        fps: this.cfg[1]
      });
      this.sprite.addAnimation({
        id: 'walk-upright',
        row: 5,
        fps: this.cfg[1]
      });
      this.sprite.addAnimation({
        id: 'walk-downright',
        row: 6,
        fps: this.cfg[1]
      });
      this.sprite.addAnimation({
        id: 'walk-upleft',
        row: 7,
        fps: this.cfg[1]
      });
      this.sprite.addAnimation({
        id: 'attack-downleft',
        row: 8,
        fps: this.cfg[2]
      });
      this.sprite.addAnimation({
        id: 'attack-upright',
        row: 9,
        fps: this.cfg[2]
      });
      this.sprite.addAnimation({
        id: 'attack-downright',
        row: 10,
        fps: this.cfg[2]
      });
      this.sprite.addAnimation({
        id: 'attack-upleft',
        row: 11,
        fps: this.cfg[2]
      });
      this.sprite.addAnimation({
        id: 'hit-downleft',
        row: 12,
        fps: this.cfg[3]
      });
      this.sprite.addAnimation({
        id: 'hit-upright',
        row: 13,
        fps: this.cfg[3]
      });
      this.sprite.addAnimation({
        id: 'hit-downright',
        row: 14,
        fps: this.cfg[3]
      });
      this.sprite.addAnimation({
        id: 'hit-upleft',
        row: 15,
        fps: this.cfg[3]
      });
      this.sprite.play('idle-' + this.lastDir);
      return this.addListener('spriteStopAnim', (function(evt) {
        if (evt.origin === this.sprite) {
          return this.sprite.play('idle-' + this.lastDir);
        }
      }).bind(this));
    };

    Unit.prototype.moveTo = function(tile) {
      var dir, dist, duration, p, speed, tween;
      speed = 0.10;
      p = tile.position;
      p = {
        x: tile.position.x,
        y: tile.position.y - (this.size.h - Common.battleField.tileHeight)
      };
      dist = Math.sqrt(Math.pow(p.x - this.position.x, 2) + Math.pow(p.y - this.position.y, 2));
      duration = dist / speed;
      if (duration === 0) {
        duration += 1;
      }
      tween = this.animateTo({
        position: p
      }, duration);
      dir = this.getDir(this.onTile, tile);
      this.sprite.play('walk-' + this.lastDir);
      return tween;
    };

    Unit.prototype.changeDir = function(dir) {
      this.lastDir = dir;
      return this.sprite.play('idle-' + this.lastDir);
    };

    Unit.prototype.getOppDir = function(dir) {
      switch (dir) {
        case "downleft":
          return "upright";
        case "upright":
          return "downleft";
        case "downright":
          return "upleft";
        case "upleft":
          return "downright";
      }
    };

    Unit.prototype.getDir = function(origin, target) {
      var colDiff, dir, rowDiff;
      rowDiff = target.row - origin.row;
      colDiff = target.col - origin.col;
      dir = '';
      if ((Math.abs(rowDiff)) >= (Math.abs(colDiff))) {
        dir = 'downleft';
        if (target.row < origin.row) {
          dir = 'upright';
        }
      } else {
        dir = 'upleft';
        if (target.col > origin.col) {
          dir = 'downright';
        }
      }
      this.lastDir = dir;
      return dir;
    };

    Unit.prototype.equip = function(item) {
      if ((__indexOf.call(this.weapons, item) >= 0) || (__indexOf.call(this.armors, item) >= 0)) {

      } else if (item instanceof Weapon) {
        if (!(this.weaponActive != null)) {
          this.weaponActive = item;
        }
        return this.weapons.push(item);
      } else if (item instanceof Armor) {
        return this.armors.push(item);
      } else {

      }
    };

    Unit.prototype.unEquip = function(item) {
      if (item instanceof Weapon) {
        return this.weapon.remove(item);
      } else if (item instanceof Armor) {
        return this.armors.remove(item);
      } else {

      }
    };

    Unit.prototype.canAttack = function(target) {
      return (this.onTile.distanceTo(target.onTile)) <= this.weaponActive.stats.range;
    };

    Unit.prototype.attack = function(target) {
      var bowSprite, bowSpriteSheet, dir, dist, duration, p, speed, tile, tween;
      dir = this.getDir(this.onTile, target.onTile);
      this.sprite.playOnce('attack-' + dir);
      target.changeDir(this.getOppDir(dir));
      switch (this.weaponActive.stats.type) {
        case "sword":
        case "spear":
          return this.doDamage(target);
        case "bow":
          bowSpriteSheet = new SpriteSheet('img/arrow.png', [
            {
              length: 1,
              cellWidth: 64,
              cellHeight: 64
            }, {
              length: 1,
              cellWidth: 64,
              cellHeight: 64
            }, {
              length: 1,
              cellWidth: 64,
              cellHeight: 64
            }, {
              length: 1,
              cellWidth: 64,
              cellHeight: 64
            }
          ]);
          bowSprite = new Sprite(bowSpriteSheet);
          bowSprite.addAnimation({
            id: 'shoot-downleft',
            row: 0,
            fps: 1
          });
          bowSprite.addAnimation({
            id: 'shoot-upright',
            row: 1,
            fps: 1
          });
          bowSprite.addAnimation({
            id: 'shoot-downright',
            row: 2,
            fps: 1
          });
          bowSprite.addAnimation({
            id: 'shoot-upleft',
            row: 3,
            fps: 1
          });
          bowSprite.setPosition(this.onTile.position.x, this.onTile.position.y);
          tile = target.onTile;
          Common.battleField.addChild(bowSprite);
          speed = 0.20;
          p = tile.position;
          dist = Math.sqrt(Math.pow(p.x - this.position.x, 2) + Math.pow(p.y - this.position.y, 2));
          duration = dist / speed;
          if (duration === 0) {
            duration += 1;
          }
          tween = bowSprite.animateTo({
            position: p
          }, duration);
          bowSprite.play('shoot-' + dir);
          return tween.onComplete((function() {
            Common.battleField.removeChild(bowSprite);
            return this.doDamage(target);
          }).bind(this));
      }
    };

    Unit.prototype.doDamage = function(target) {
      var a, armor, damage, log, rand, _i, _len, _ref;
      console.log('doDmg');
      if (Math.random() > target.stats.evasion * 0.5) {
        rand = Math.random();
        if ((!target.weaponActive) || (rand > target.getWeaponParry() + target.stats.skill * 0.05)) {
          armor = 0;
          _ref = target.armors;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            a = _ref[_i];
            armor += a.stats.defence;
          }
          damage = this.weaponActive.stats.power + this.stats.skill - armor;
          if (damage < 0) {
            damage = 0;
          }
          if (damage >= target.curhp) {
            target.curhp = 0;
          } else {
            target.curhp -= damage;
          }
          Common.audios.hurt.play();
          log = this.stats.name + " attacked " + target.stats.name + " to do " + damage + " damage. " + target.stats.name + "  has " + target.curhp + " HP remaining.";
          target.sprite.playOnce('hit-' + target.lastDir);
        } else {
          target.sprite.playOnce('attack-' + target.lastDir);
          log = 'Attack got parried';
        }
      } else {
        target.sprite.playOnce('walk-' + target.lastDir);
        log = 'Attack got evasiond';
      }
      if (target.curhp <= 0) {
        Common.battleField.removeUnit(target);
      }
      if ((Common.state.turn !== this.enemy) && (Common.enemy.units.length === 0)) {
        Common.state.endTurn();
      }
      return Common.game.battleLog(log);
    };

    Unit.prototype.getWeaponParry = function() {
      if (this.weaponActive != null) {
        return this.weaponActive.getParry();
      } else {
        return 0;
      }
    };

    Unit.prototype.getWeaponRange = function() {
      if (this.weaponActive != null) {
        return this.weaponActive.getRange();
      } else {
        return 0;
      }
    };

    Unit.prototype.useSkill = function(skillType, target) {
      switch (this.type) {
        case "":
          break;
        case "":
          break;
      }
    };

    return Unit;

  })(BFObject);

}).call(this);
